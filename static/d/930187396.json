{"data":{"allMediumFeed":{"nodes":[{"title":"git-tip: Managing your temporary code with stashed patches","link":"https://medium.com/@hndmrsh/git-tip-managing-your-temporary-code-with-stashed-patches-f59a6903f131?source=rss-1c5d88d3807------2","date":"09-28-2020","content":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*_sfAUC5FHJNe9O6n-OLevg.jpeg\" /><figcaption>Image by <a href=\"https://pixabay.com/users/Bru-nO-1161770/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3365703\">Bruno /Germany</a> from <a href=\"https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=3365703\">Pixabay</a></figcaption></figure><p>Sometimes in software development, you just need to write some temporary code. I’m not talking about the quote-unquote “temporary” code that you occasionally find woven into the very fabric of the company, code that’s only weeks away from receiving a lifetime achievement award — I’m talking about temporary code that helps you develop faster, but will never be shipped. For example, perhaps you’re building a new feature that exists at the end of a complex flow, and you just want to add a little shortcut for yourself. Or perhaps you’re building around a system that doesn’t yet exist, so you want to hard-code in some dependencies. Whatever the reason, you know you don’t want this code in your repo — this is for your eyes only!</p><p>Here’s a little workflow I discovered today which you might find useful in these situations — this may be obvious to you, but hopefully it will help someone out:</p><ol><li>From a clean workspace, write your temporary code.</li><li>Stash your changes with git stash push -a -m &quot;Patch for temporary workaround&quot; (message optional).</li><li>Apply (don’t pop) your stash with git stash apply ¹.</li><li>Write your feature code.</li><li>When it comes time to commit your feature code, unpatch your temporary code with git stash show -p | git apply --reverse ¹ — this should leave your workspace in a place where only your feature code (which you actually want to commit) exists.</li><li>Commit your feature code.</li><li>Repeat steps 3–6 as required.</li></ol><p>[1] Note: if you have stashed/unstashed work as part of your feature development (step 4), you may need to refer to your temporary code patch by its index — you can find this with git stash list.</p><p>By following these steps, you can safely write whatever temporary code you need to be efficient!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f59a6903f131\" width=\"1\" height=\"1\" alt=\"\">"},{"title":"Dear Dagger: I’ve found someone new","link":"https://medium.com/@hndmrsh/dear-dagger-ive-found-someone-new-966314dcdc5f?source=rss-1c5d88d3807------2","date":"11-06-2019","content":"<h4>Koin is a dependency injection library that truly loves me</h4><p><em>Dear Dagger,</em></p><p><em>We’ve had some great times together, and I’ll always hold you dear to my heart. You introduced me to a world in which I always </em><a href=\"https://en.wikipedia.org/wiki/Dependency_injection\"><em>get what I want</em></a><em>. You helped me get what I needed before I even knew I needed it. You’ve helped me </em><a href=\"https://en.wikipedia.org/wiki/Unit_testing\"><em>be more confident in myself</em></a><em>.</em></p><p><em>But we’ve grown apart. You’re complicated. You’re difficult. You take up so much of my time. I’ve found another library that I feel a stronger connection with. They get me; I get them.</em></p><p><em>I’ll never forget you.</em></p><p>I have a confession to make: I don’t really understand how Dagger works. I’ve used it plenty, and reaped the benefits, but I’ve always struggled with it. It’s a complex beast, and I’ve never fully grasped it. Until now, I’ve been putting off implementing dependency injection in my Android project because I’ve been dreading trying to once more attempt to work out the best approach for the task. While Dagger is often praised for its flexibility, I didn’t want to have to spend hours deciding between the numerous implementation strategies for my small project — I don’t think I’ve ever read two blog posts which have implemented it the same way, and I wasn’t prepared to make that decision.</p><figure><img alt=\"Stacks of coins\" src=\"https://cdn-images-1.medium.com/max/1024/0*PDhdr-rgo6F2cL5x\" /><figcaption>Photo by <a href=\"https://unsplash.com/@photoripey?utm_source=medium&amp;utm_medium=referral\">Ibrahim Rifath</a> on <a href=\"https://unsplash.com?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><h3>Koin operated</h3><p>Being a Kotlin developer, I had heard of <a href=\"https://insert-koin.io/\">Koin </a>before. I had always written it off as the less mature, less powerful alternative to Dagger. For my project, however, it revealed itself to me once more, and this time stood out as a potential solution to my problem. Koin sells itself as a <em>“</em> <em>pragmatic lightweight dependency injection framework</em>” — I needed to know for myself just how pragmatic and lightweight it was.</p><h4>Set up</h4><p>Setting Koin up in an Android project is simple, and gives a good glimpse into its functional approach. All it requires is invoking the startKoin function in your App class and giving it a bunch of modules with which it can resolve dependencies.</p><pre><em>startKoin </em><strong>{</strong><br>    <em>androidContext</em>(<strong>this</strong>@App)<br>    modules(<em>listOf</em>(<br>            <em>databaseModule</em>,<br>            <em>mediaManagerModule</em>,<br>            <em>addItemModule<br>    </em>))<br><strong>}</strong></pre><p>You might choose to combine all your globally-scoped dependencies into a single appModule; my project uses features packages, so I wanted to have one module per feature — for example, the ../feature/additem/model/AddItemRepository class is injected by the ../feature/additem/di/AddItemModule.</p><p>What do the modules look like, you may ask? Well, that’s simple too!</p><pre><strong>val </strong><em>mediaManagerModule </em>= <em>module </em><strong>{<br>    </strong>single <strong>{<br>        </strong>MediaManager()<br>    <strong>}<br>}</strong></pre><p>That’s all that’s required for a globally-scoped singleton — Koin will now be able to provide you with a reference to the MediaManager wherever you need it. Looking good so far!</p><h4>Scoped dependencies</h4><p>If you’re using Jetpack’s Architecture Components, your ViewModels will (usually) have a one-to-one relationship with your Fragments or Activities, so it makes sense to scope them appropriately. Each of my features has its own Repository which provides access to the database, so this should be similarly scoped. Additionally, both the ViewModel and the Repository will have their own dependencies — the Repository is a dependency of the ViewModel, and the ViewModel also needs reference to the MediaManager singleton. Additionally, the Repository needs a reference to the appropriate <a href=\"https://en.wikipedia.org/wiki/Data_access_object\">DAOs</a> from the Database singleton.</p><p>How do we represent this using Koin? Easy!</p><pre><strong>val </strong><em>addItemModule </em>= <em>module </em><strong>{<br>    </strong>scope(<em>named</em>&lt;<strong>AddItemFragment</strong>&gt;()) <strong>{<br>        </strong>scoped <strong>{<br>            </strong>AddItemRepository(<br>                    get&lt;<strong>Database</strong>&gt;().itemDao()<br>            )<br>        <strong>}<br>        </strong><em>viewModel </em><strong>{<br>            </strong>AddItemViewModel(get(), get())<br>        <strong>}<br>    }<br>}</strong></pre><p>So what’s going on here? Simple: we’ve created a scope which is named using the Fragment that the scope surrounds. Inside the scope, we’ve declared two things: a scoped singleton dependency of AddItemRepository, and a viewModel dependency of AddItemViewModel (which tells Koin to provide the AddItemViewModel using Jetpack’s ViewModelProviders static functions).</p><p>You might be wondering what the get() function does here. get() is the glue that helps us stick dependencies together by using Koin to inject dependencies that were declared either in this Module or a different one. When we constructed the AddItemRepository above, we told Koin to give us our Database dependency so that we can provide the approriate DAO; when we constructed the ViewModel, we told Koin to provide us with the AddItemRepository we just declared as well as the MediaManager singleton we declared in our previous globally-scoped module. Thanks to Kotlin’s generic type inference, we don’t need to specify the type returned by each call of the get() function, but note that each invocation returns a different type (see the declaration of the AddItemViewModel constructor below for clarification).</p><p>And that’s all we need to do to provide AddItemFragment its dependencies. If we wanted to share these dependencies across multiple Fragments, all we would have to do is pass a String into the non-generic overload of the named function — for example, named(&quot;USER_SESSION&quot;) — and retrieve the dependencies from that scope in the appropriate Fragments using getKoin().getScope(name).</p><h4>Injection</h4><p>Before setting up dependency injection, our AddItemFragment looked something like this:</p><pre><strong>class AddItemFragment </strong>: Fragment() {<br><br>    <strong>private lateinit var </strong>viewModel: <strong>AddItemViewModel<br><br>    override fun </strong>onActivityCreated(savedInstanceState: <strong>Bundle</strong>?) {<br>        viewModel = <strong>ViewModelProviders</strong>.of(<strong>this</strong>)<br>                .get(<strong>AddItemViewModel</strong>::<strong>class</strong>.<em>java</em>)<br>    }</pre><pre>}</pre><p>And our AddItemViewModel looked something like this:</p><pre><strong>class AddItemViewModel</strong>(app: <strong>Application</strong>) : AndroidViewModel(app) {<br><br>    <strong>private val </strong>repository = <strong>AddItemRepository</strong>(<br>            <strong>Databse</strong>.getDatabase(application).itemDao()<br>    )<br><br>    <strong>private val </strong>mediaManager: <strong>MediaManager </strong>= MediaManager()<br>    <br>}</pre><p>Good luck mocking out those dependencies for unit testing purposes!</p><p>OK, so let’s see how things look with our dependencies injected:</p><pre><strong>class AddItemFragment </strong>: Fragment() {<br><br>    <strong>private val </strong>viewModel <br>        <strong>by </strong><em>currentScope</em>.<em>viewModel</em>&lt;<strong>AddItemViewModel</strong>&gt;(<strong>this</strong>)<br><br>}</pre><p>Remember that we scoped our ViewModel to its corresponding Fragment in our Module, so we need to resolve it by using the correct scope. Koin provides us a nice shortcut to do this with — currentScope will return the scope that was named&lt;AddItemFragment&gt;. <strong>Nice</strong>.</p><p>And the ViewModel?</p><pre><strong>class AddItemViewModel</strong>(<br>        <strong>private val </strong>repository: <strong>AddItemRepository</strong>,<br>        <strong>private val </strong>mediaManager: <strong>MediaManager<br></strong>) : ViewModel()</pre><p><em>Lovely. </em>Our dependencies have now been provided for us in the constructor, which means we can easily provide mocks instead when unit testing. What’s more, things are scoped appropriately, enforcing good engineering practice: AddItemRepository is only accessible from the “add item” context, while the MediaManager — a helper class for handling photo and video files — is a singleton shared across the app.</p><h3>Closing thoughts</h3><p>Time will tell how Koin scales in my project, but I’m extremely happy with my initial experience. It has provided a clean and easy implementation of dependency injection, and it was fast to learn and implement — even faster than it took me to write this post, in fact! And while I previously understood the concepts behind dependency injection, Koin has helped to demystify the implementation details which so often prevented me from loving Dagger unconditionally.</p><p>If you find yourself getting lost in the weeds with Dagger, give Koin a go. Its simplicity may just help you get over that hump.</p><p>If you enjoyed this post, don’t forget to 👏, and then follow me on Twitter <a href=\"http://twitter.com/hndmrsh\">@hndmrsh</a>.</p><p>I’m also available for work, so <a href=\"https://www.linkedin.com/in/hndmrsh/\">connect with me on LinkedIn</a> too!</p><p><em>Thanks to /u/Zhuinden for pointing out that </em><a href=\"https://www.reddit.com/r/androiddev/comments/dsqpiy/dear_dagger_ive_found_someone_new_a_koin_love/f6s4c1a?utm_source=share&amp;utm_medium=web2x\"><em>the ViewModels no longer have to subclass AndroidViewModel</em></a><em>.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=966314dcdc5f\" width=\"1\" height=\"1\" alt=\"\">"},{"title":"Plunge — better deep linking for Android apps","link":"https://medium.com/default-to-open/plunge-better-deep-linking-for-android-apps-f331d0bb4648?source=rss-1c5d88d3807------2","date":"04-02-2019","content":"<h3>Plunge — better deep linking for Android apps</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*Vl120ljVMPcoTGZE8GFpWA.jpeg\" /><figcaption>Plunge into the depths of your app</figcaption></figure><p>If you build or maintain an app which has a corresponding website, then you’ll no doubt be aware of the hassle of dealing with deep linking. Ensuring your intent filters handle the right URLs and your routing logic is correct can be a real challenge. While it’s possible to write comprehensive unit tests for your routing logic, doing the same for your intent filters isn’t quite as straightforward.</p><p>Unless, of course, you use <a href=\"https://github.com/TradeMe/Plunge\">Plunge</a>…</p><h3>What is Plunge?</h3><p>Plunge simplifies matching URLs to callbacks when a deep link is handled by the app, and provides an easy, coherent solution to verifying the behaviour of both your intent filters and your routing logic. Plunge gives you a simple domain-specific language to handle the routing, which includes the ability to extract useful information out of the URL required to route the user correctly.</p><h4>Yeah, but… what IS Plunge, really?</h4><p>Well, Plunge is a UrlSchemeHandler…</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3c5e31a08f45b2bb339bfb6b687eaf1a/href\">https://medium.com/media/3c5e31a08f45b2bb339bfb6b687eaf1a/href</a></iframe><p>… which you use in your Activity…</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5ca46ce56f12175a9923f2de69077c2e/href\">https://medium.com/media/5ca46ce56f12175a9923f2de69077c2e/href</a></iframe><p>… which you can write tests in JSON for…</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/1441cb0b784c8fef00ac4ed997495731/href\">https://medium.com/media/1441cb0b784c8fef00ac4ed997495731/href</a></iframe><p>… which can be run as unit tests to test the routing logic…</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/52f4db14e7c39edd38da5973e8fa8b9b/href\">https://medium.com/media/52f4db14e7c39edd38da5973e8fa8b9b/href</a></iframe><p>… or as a Gradle task to verify the intent filters.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/95555a55680859574cd5569aa6138869/href\">https://medium.com/media/95555a55680859574cd5569aa6138869/href</a></iframe><p>And that’s Plunge!</p><h3>Check it out!</h3><p>Plunge is <a href=\"https://github.com/TradeMe/Plunge\">available on GitHub</a> — full installation and implementation instructions are there.</p><p>Don’t forget to 👏, and follow me on all the socials <a href=\"http://twitter.com/hndmrsh\">@hndmrsh</a>. Also, check out Plunge co-author <a href=\"https://medium.com/u/68342880d9e0\">Jamie Sanson</a>’s post for <a href=\"https://medium.com/default-to-open/app-links-in-a-multi-app-ecosystem-f86e6c1e32e6\">more deep linking advice</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f331d0bb4648\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/default-to-open/plunge-better-deep-linking-for-android-apps-f331d0bb4648\">Plunge — better deep linking for Android apps</a> was originally published in <a href=\"https://medium.com/default-to-open\">Default to Open</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},{"title":"Tauhoko i Android","link":"https://medium.com/default-to-open/tauhoko-i-android-aee53c5fa975?source=rss-1c5d88d3807------2","date":"11-12-2018","content":"<h4>Supporting te reo Māori on Trade Me for Android (and why it’s such a challenge)</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*PgumUSrTditabThl6gmR0g.png\" /></figure><p><a href=\"https://play.google.com/store/apps/details?id=nz.co.trademe.trademe\">Trade Me for Android</a> has begun to learn a little te reo Māori! We’ve held off translating the app until now due to the lack of Māori language support in Android devices, but thanks to a little bit of development magic, we will soon be able to offer te reo to all our Android users. For the moment, though, you will only be able to use the app in te reo Māori if your device supports it — at the time of writing, this is limited to a few Huawei devices only.</p><p><a href=\"https://medium.com/default-to-open/supporting-te-reo-m%C4%81ori-59cafec7eb8b\">Similarly to the iOS app before it</a>, Trade Me for Android will only show te reo in some of the most used parts of the app to begin with, but we’ll continue to translate more and more of the app over time.</p><h3>Supporting te reo on all Android devices</h3><p>While the Android platform has built-in support for a huge number of languages, the devices shipped by manufacturers support a much smaller number. The reason for this is because manufacturers have to ensure that all the custom software they put on their device — including device settings, the phone app, the text messaging app, and so on — is translated into each of the languages they support. This is a huge amount of work, which means manufacturers need to make tough decisions about which languages make the cut. Unfortunately for us Kiwis, te reo Māori is rarely one of them.</p><p>The good news is, Android is a very flexible development platform. Although you may not be able to set your device’s language to te reo Māori, we can trick our app into thinking your device is fluent! We can do this by overriding the locale set in the application’s configuration at runtime, manually setting te reo as your preferred language for every screen in the app. Combined with the ability to set your preferred language from our app settings, you’ll be able to use Tauhoko regardless of which device you choose.</p><p>Android developers: if you’re interested in supporting te reo Māori in your apps, get in touch. We’ll be sharing more detail about how you can make these changes to your apps soon.</p><p>Owners of non-Huawei devices: keep an eye out for future app releases — we’ll be bringing te reo Māori support to all devices very soon.</p><p>Mā te wā!</p><p>If you want to get in touch with me directly, feel free to <a href=\"http://twitter.com/hndmrsh\">reach out on Twitter</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=aee53c5fa975\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/default-to-open/tauhoko-i-android-aee53c5fa975\">Tauhoko i Android</a> was originally published in <a href=\"https://medium.com/default-to-open\">Default to Open</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"}],"totalCount":4}}}